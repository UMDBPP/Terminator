This project was originally generated by the STM32 Cube IDE. I just stole it and rippped it apart so I could build it myself and not be forced to use their IDE. Hopefully I'll also be able to steal some of their HAL functions too since I don't want to have to write them myself. The original project I used can be found in "empty_test_proj.zip"

# Project Structure
The structure of the project isn't too complicated.
- **build**: this fold contains the makefile and linker script used to build the final .elf file and other artifacts created during a build
- **src**: this contains source files that YOU write, things like main.c and other small or libraries
- **lib**: this is where you should put libraries you need to use for things like accessing I2C devices or parsing GPS data
- **vendor**: this includes code written by ARM and ST which perform basic configuration functions (e.g. the basic assembly run by the processor at startup that puts your application code in the right place in memory), unless you know what you are doing in here don't touch
    - **CMSIS**: this is the core stuff that configures the processor
    - **STM32L4_HAL**: this is hardware abstraction layer code written by ST, it should make things like using ADCs and configuring GPIOs easier, it is documented in ST UM1884 (google it)

## External Software Versions
ARM CMSIS, ST CMSIS, and the STM32 HAL found in the vendor directory are all external software provided by vendors. As described here: https://htmlpreview.github.io/?https://github.com/STMicroelectronics/STM32CubeL4/blob/master/Release_Notes.html, they need to have the correct versions installed to function properly.

These version numbers are denoted by the release tags shown in Git or on the Github website and it's very easy to move between versions.

1. First check the versions you need by going to the link above and scrolling down to `Components > Drivers`
2. `cd` into `Terminator/Firmware/gen_proj/vendor/CMSIS`
3. List all available tags using `git tag`
4. Switch to the tag corresponding to the desired version number with `git checkout tags/<tag> -b <branch>`
    - Where `<tag>` is probably something like `5.6.0` and `<branch>` is probably `main`
5. Then confirm which tag you are on with `git describe --exact-match --tags`
6. Repeat steps 3-5 but first `cd Terminator/Firmware/gen_proj/vendor/CMSIS/Device/ST/STM32L4`
7. Repeat steps 3-5 but first `cd Terminator/Firmware/gen_proj/vendor/STM32L4_HAL`

# Building
The `build` folder is where the magic happens. The critical things it contains are: 

- **`makefile`**: contains the "recipe" for compiling code and creating an executable
- **`*.elf`**: the final executable, this is loaded onto a microcontroller and run
- **linker script**: a file that tells the linker where to put code in memory so that it will run properly

The TLDR steps for just building and flashing something are this:
1. `cd build` and run `make`
2. If you are connected to the MCU with an ST Link or some other programmer/debugger that is OpenOCD compatible, run `make flash`
3. If you are just connected over USB, but the device in USB DFU mode and flash the `.elf` file found in `build` to the device using the STM32 Programmer application

# References
Things I used to figure this out.
- ENEE440 - great class IMO, but I'm really into all this stuff so YMMV
- https://kleinembedded.com/stm32-without-cubeide-part-1-the-bare-necessities/
    - this really does explain most of it quite nicely, I had to figure some things out on my own to get this approach working with ST's provided startup and linker scripts
- https://vivonomicon.com/2018/04/02/bare-metal-stm32-programming-part-1-hello-arm/
- https://gist.github.com/maxtruxa/4b3929e118914ccef057f8a05c614b0f for the original Makefile